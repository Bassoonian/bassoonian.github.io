<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title id="page_title">Loading...</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<script src="jquery.csv.js"></script>
	<style>
	body
	{
		margin: 0;
		overflow: hidden;
		height: 100%;
	}
	#wordlist
	{
		padding: 0;
		position: fixed;
		height: calc(100% - 52px);
		top: 52px;
		overflow-y: scroll;
	}
	#actualcontent, #loadingcontent
	{
		position: fixed;
		padding: 0;
		height: calc(100% - 52px);
		top: 52px;
		left: calc(100% / 6);
		right: 0px;
		overflow-y: auto;
	}
	#actualcontent
	{
		display: none;
	}
	.alphabetstripe
	{
		display: block;
		overflow: hidden;
		white-space: nowrap;
		text-align: center;
	}
	.alphabetstripe > span
	{
		position: relative;
		display: inline-block;
	}
	.alphabetstripe > span:after, .alphabetstripe > span:before
	{
		content: "";
		position: absolute;
		top: 50%;
		width: 9999px;
		height: 1px;
		background: #ccc;
	}
	.alphabetstripe > span:after
	{
		left: 100%;
		margin-left: 5px;
	}
	.alphabetstripe > span:before
	{
		right: 100%;
		margin-right: 5px;
	}
	.wordentry
	{
		padding: 1px;
		margin: 1px;
		cursor: pointer;
		-o-transition: color .2s ease-out, background .1s ease-out;
		-ms-transition: color .2s ease-out, background .1s ease-out;
		-moz-transition: color .2s ease-out, background .1s ease-out;
		-webkit-transition: color .2s ease-out, background .1s ease-out;
		transition: color .2s ease-out, background .1s ease-out;
	}
	.wordentry:hover
	{
		background-color: #E8E8E8;
	}
	#entryamountbox
	{
		text-align: center;
		padding-top: 1px;
		padding-bottom: 0px;
		margin-bottom: 0px;
	}
	.rtl
	{
		display: inline-block;
		transform: scaleX(-1); 
		filter: FlipH; /* IE 6-7-8 */
		direction: rtl;
		unicode-bidi: bidi-override;
	}
  	</style>
</head>
<body>
<nav class="navbar navbar-inverse">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>                        
			</button>
			<a class="navbar-brand" id="lang_name" href="#"><!-- Carite--></a>
		</div>
		<div class="collapse navbar-collapse" id="myNavbar">
			<ul id="navbar_alphabetlist" class="nav navbar-nav"></ul>
				<div class="navbar-form navbar-right">
					<div class="input-group">
						<input type="text" id="searchinputvalue" class="form-control" placeholder="Search" name="search" oninput="setWordlist();">
						<div class="input-group-btn">
							<button class="btn btn-default" data-toggle="modal" data-target="#searchsettingsmodal">
								<i class="glyphicon glyphicon-cog"></i>
							</button>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</nav>   
<div class="row">
	<div id="wordlist" class="col-sm-2" data-spy="scroll" data-target=".navbar" data-offset="0"></div>
	<div class="col-sm-10">
		<div id="loadingcontent" class="container-fluid"></div>
		<div id="actualcontent" data-spy="affix" class="container-fluid">
			<div class="alert alert-info alert-dismissable fade in" id="wotdnotice">
				<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
				<strong>Notice:</strong> This entry was opened automatically as the word of the day.
			</div>
			<h2 id="entry_name"></h2>
			<h3 id="entry_category"></h3>
			<ul class="nav nav-tabs">
				<li class="active"><a data-toggle="tab" href="#tab_general" id="tab_click_general">General</a></li>
				<li id="tab_inflect_li"><a data-toggle="tab" href="#tab_inflection" id="tab_click_inflection">Inflection</a></li>
				<li><a data-toggle="tab" href="#tab_etymo" id="tab_click_etymo">Etymology</a></li>
				<li><a data-toggle="tab" href="#tab_sources" id="tab_click_sources">Sources</a></li>
			</ul>
			<div class="tab-content">
				<div id="tab_general" class="tab-pane fade in active">
					<h4>Pronunciation</h4>
					<ul id="entry_pronunciation"></ul>
					<p id="dicentry_gender"><b>Gender:</b> <span id="dicentry_gender2"></span></p>
					<h4>Translation</h4>
					<ol id="entry_translations">
					</ol>
				</div>
				<div id="tab_inflection" class="tab-pane fade">
					<h4>Inflection</h4>
					<div class='col-md-4'>
						<table class='table table-striped table-condensed'>
							<thead>
								<tr id='inflection_thead_name'></tr>
								<tr id='inflection_thead'></tr>
								<tr id='inflection_thead2'></tr>
							</thead>
							<tbody id='inflection_tbody'>
							</tbody>
						</table>
					</div>
				</div>
				<div id="tab_etymo" class="tab-pane fade">
					<h4>Etymology</h4>
					<p id="entry_etymologytext"></p>
				</div>
				<div id="tab_sources" class="tab-pane fade">
					<h4>Sources</h4>
					<p id="entry_etymologytext"></p>
				</div>
			</div>
		</div>
		<div class="modal fade" id="searchsettingsmodal" role="dialog">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal">&times;</button>
						<h4 class="modal-title">Search settings</h4>
					</div>
					<div class="modal-body">
						<h4>Dictionary Settings</h4>
						<p>Primary notation:
							<input type="radio" name="search_prim_input" value="roman" checked> Romanisation
							<input type="radio" name="search_prim_input" value="native"> Native Script
						</p>
						<p>Active stage: <select id="stageselectlist" onchange="updateStage();">
							</select>
						</p>
						<h4>Search Settings</h4>
						<p>Search bar purpose:
							<input type="radio" name="search_destination" value="lang" checked onchange="cleanSearch();"> Language
							<input type="radio" name="search_destination" value="eng" onchange="cleanSearch();"> Translations
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</body>
<script>
	//Initialise important variables
	_alphabet=["A~Ä€ B D E~Ä’ F G H I~Äª J K L M N O~ÅŒ P R S T U~Åª V W È² Z Ã˜Ì„","A~Ä€~Ä„~Ä„Ì„ B D E~Ä’~Ä˜~Ä˜Ì„ F G H I~Äª~Ä®~Ä®Ì„ J K L M N O~ÅŒ~Çª~ÇªÌ„ P R S T U~Åª~Å²~Å²Ì„ V W Y~È²~YÌ¨~YÌ¨Ì„ Z Ã˜~Ã˜Ì„~Ã˜Ì¨~Ã˜Ì¨Ì„","A~Ä€ B D E~Ä’~Ä˜~Ä˜Ì„ F G H I~Äª J K L M N O~ÅŒ~Çª~ÇªÌ„ P R~Ê€ S T U~Åª~Å²~Å²Ì„ V W Y~È² Z Ã†~Ã†Ì„ Ã˜~Ã˜Ì„"];
	_alphabet2=["ğŒ€ ğŒ ğŒƒ ğŒ„ ğŒ… ğŒ‚ ğŒ‡ ğŒ‰ ğŒŠ ğŒ‹ ğŒŒ ğŒ ğŒ ğŒ ğŒ“ ğŒ” ğŒ• ğŒ– ğŒ† ğŒ—","",""];
	activestage=_alphabet.length-1;
	romanisationfirst=true;
	includeother=true;
	searchenglish=false;
	sources=[
		["ed_pgmc"	,"Kroonen, Guus. Etymological Dictionary of Proto-Germanic. Leiden, Koninklijke Brill NV, 2013."],
		["ed_greek"	,"Beekes, Robert. Etymological Dictionary of Greek. Leiden, Koninklijke Brill NV, 2010."],
		["ed_pcelt"	,"MatasoviÄ‡, Ranko. Etymological Dictionary of Proto-Celtic. Leiden, Koninklijke Brill NV, 2009."],
		["ed_latin"	,"de Vaan, Michiel. Etymological Dictionary of Latin and the other Italic Languages. Leiden, Koninklijke Brill NV, 2008."],
		["ed_slavic","Derksen, Rick. Etymological Dictionary of the Slavic Inherited Lexicon. Leiden, Koninklijke Brill NV, 2008."],
		["oxf_intro","Mallory, J. P. and Adams, D. Q. The Oxford Introduction to Proto-Indo-European and the Proto-Indo-European World. New York, Oxford University Press Inc., 2006."]
	]
	
	//Load csv from Google Sheets as javascript array
	loadstr="";
	loadNote("Loading...");
	rawcsv=$.get("https://docs.google.com/spreadsheets/d/e/2PACX-1vTe8E8yH60LpBJZA9PfIgIfj7RxmVIPm97PUB1GBHEYPoT9G8dOfyFscqPYhHaEtbQ0Gt3xh6ESfQbF/pub?gid=284553596&single=true&output=csv", function() {
		loadNote("Attempting to connect to server...");
	})
		.done(function(){
			loadNote("Lexicon retrieval succesful!");
			dbase=$.csv.toArrays(rawcsv.responseText);
			parseDbase();
		})
		.fail(function(){
			loadNote("Unable to connect to Google, quite possibly because of Cross-Origin Restrictions.");
			loadNote("Want to debug the latest changes to your spreadsheet? Turn off Cross-Origin Restrictions for this page and refresh.");
			rawcsv=$.get("backup_csv.csv", function() {
				loadNote("Attempting to read local file...");
			})
				.done(function(){
					loadNote("Lexicon retrieval succesful!");
					dbase=$.csv.toArrays(rawcsv.responseText);
					parseDbase();
				})
				.fail(function(){
					loadNote("No local copy can be found.");
					loaderror();
				});
		});
	
	function loaderror()
		{
			alert("An error has occurred while loading the lexicon. Please try again later.");
		}
		
	function loadNote(txt)
		{
			if (loadstr!="") loadstr+="</br>";
			loadstr+=txt;
			document.getElementById("loadingcontent").innerHTML=loadstr;
		}
	
	function parseDbase()
		{
			//Scouts the array for important bits of information such as the stage names and result/ortho columns
			loadNote("Analysing different stages...");
			maincolumns=[];
			sourcecolumn=-1;
			cognatecolumn=-1;
			var k=dbase[1].length;
			for(var i=0;i<k;i++)
			{
				if (dbase[1][i]=="RESULT") maincolumns.push(i);
				if (dbase[1][i]=="COGNATE") cognatecolumn=i;
				if (dbase[1][i]=="SOURCE") sourcecolumn=i;
			}
			if (maincolumns.length==0)
			{
				loaderror();
				return;
			}
			
			stagelist=[];//List of different stage starts and names
			happenings=[];//Above but also includes loans
			applyalwayses=[];//List of when applyalwayses start/end
			allophonies=[];//List of when allophones start/end
			for(var i=3;i<dbase[0].length;i++)
			{
				if (dbase[0][i]!="")//Non-empty in this row means a new stage has started
				{
					stagelist.push([dbase[0][i],i]);
				}
				if (dbase[1][i]=="LOANS"||dbase[1][i]=="RESULT") happenings.push([dbase[2][i],i]);
				if (dbase[1][i]=="applyalways") applyalwayses.push([dbase[2][i],i]);
				if (dbase[1][i]=="allophony") allophonies.push([dbase[2][i],i]);
			}
			loadNote("Stages: "+stagelist);
			loadNote("Happenings: "+happenings.length);
			loadNote("Apply Always: "+applyalwayses.length);
			loadNote("Allophonies: "+allophonies.length);
			//Gather words and figure out the size of the lexicon
			lexlist=[];
			var endoflexicon=-1;
			var cat="";
			for(var i=3;i<dbase.length;i++)
			{
				if (dbase[i][0]=="//") cat=dbase[i][1];
				else if (dbase[i][0]=="@@@@")
				{
					endoflexicon=i;
					i=dbase.length;
				}
				else if (dbase[i][0].charAt(0)!="Â§"&&dbase[i][0]!="!!!") lexlist.push([i,cat]);
			}
			if (endoflexicon==-1)
			{
				loaderror();
				return;
			}
			loadNote("Words: "+lexlist.length);
			//Declension lists
			declensionlist=[];
			for(var i=endoflexicon;i<dbase.length;i++)
			{
				if (dbase[i][0]=="//") declensionlist.push([dbase[i][1],i]);
			}
			loadNote("Inflection patterns: "+declensionlist.length);
			
			loadstr=""; //Free up memory
			//Switch from loading screen to actual content
			document.getElementById("loadingcontent").style.display="none";
			document.getElementById("actualcontent").style.display="block";
			document.getElementById("page_title").innerHTML="Carite Lexicon";
			
			//Update stage list in search menu
			for(var i=0;i<stagelist.length;i++)
			{
				loadstr+="<option";
				if (i==activestage) loadstr+=" selected";
				loadstr+=">"+stagelist[i][0]+"</option>";
			}
			document.getElementById("stageselectlist").innerHTML=loadstr;
			loadstr="";
			
			//Load last stage
			loadStage(activestage);
		}
	function parseAlphabet(stagid)
		{
			//Parse alphabet
			var tempvar="";
			var alph=[];
			if (romanisationfirst==true) alph=_alphabet[stagid].split(" ");
			if (romanisationfirst==false&&_alphabet2[stagid]!="") alph=_alphabet2[stagid].split(" ");
			active_alphabet=[];
			var j=[];
			var alphvalue=0;
			for(var i=0;i<alph.length;i++)
			{
				j=alph[i].split("~");
				if (j.length>1)
				{
					//Dropdown menu
					tempvar+="<li class='dropdown'><a class='dropdown-toggle' data-toggle='dropdown' href='#'>"+j[0]+" <span class='caret'></span></a><ul class='dropdown-menu'>";
					for(var k=0;k<j.length;k++)
					{
						tempvar+="<li><a href='#scr"+alphvalue+"'>"+j[k]+"</a></li>";
						active_alphabet.push(j[k]);
						alphvalue++;
					}
					tempvar+="</ul></li>";
				}
				else
				{
					tempvar+="<li><a href='#scr"+alphvalue+"'>"+j[0]+"</a></li>";
					active_alphabet.push(j[0]);
					alphvalue++;
				}
			}
			document.getElementById("navbar_alphabetlist").innerHTML=tempvar;
		}
	function loadStage(stagid)
		{
			//document.getElementById("lang_name").innerHTML=stagelist[stagid][0].toUpperCase();
			parseAlphabet(stagid);
			//Create list of terms
			wordlist=[];
			var orth="";
			for(var i=0;i<lexlist.length;i++)
			{
				orth=apply_orthography(dbase[lexlist[i][0]][maincolumns[stagid]],stagid);
				if (orth!="") //If empty, this word does not yet/no longer exist in this stage!
				{
					orth2=apply_nativealphabet(orth,stagid);
					wordlist.push([orth,orth2,lexlist[i][0],lexlist[i][1]]);
				}
			}
			//Order alphabetically
			order_alph(stagid);
			setWordlist(stagid);
			openWotd();
		}
	function apply_orthography(word,stage)
		{
			var w=word;
			if (stage==1)
			{
				w=replaceAll("X","H",w);
				w=replaceAll("x","h",w);
				w=replaceAll("Ì¯","",w);
			}
			return(w);
		}
	function apply_nativealphabet(word,stage)
		{
			return(word);
		}
	function order_alph(stagid)
		{
			//This function orders the world list alphabetically - either by romanisation or native script
			if (romanisationfirst==true||_alphabet2[stagid]=="") wordlist.sort(function(a,b){
				return(strSortAlph(a[0].toUpperCase(),b[0].toUpperCase()));
			});
			else wordlist.sort(function(a,b){
				return(strSortAlph(a[1].toUpperCase(),b[1].toUpperCase()));
			});
		}
	function strSortAlph(a,b)
		{
			a=replaceAll("-","",a);
			b=replaceAll("-","",b);
			for(var i=0;i<a.length&&i<b.length;i++)
			{
				var cha=active_alphabet.indexOf(a[i]);
				var chb=active_alphabet.indexOf(b[i]);
				if (cha<chb) return -1;
				if (cha>chb) return 1;
			}
			return 0;
		}
		function replaceAll(find, replace, string) {
			  return string.replace(new RegExp(escapeRegExp(find), 'g'), replace);
			}
			function escapeRegExp(string) {
				    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
				}
	function setWordlist(stagid)
		{
			var temp="";
			var alphvalue=-1;
			var foundresult=0;
			var searchval=document.getElementById("searchinputvalue").value;
			var check=0;
			if (romanisationfirst==false&&_alphabet2[stagid]!="") check=1;
			for(var i=0;i<wordlist.length;i++)
			{
				var j=wordlist[i][check].charAt(0).toUpperCase();
				if(j=="-") j=wordlist[i][check].charAt(1).toUpperCase();
				while(alphvalue<active_alphabet.indexOf(j))
				{
					alphvalue++;
					if (alphvalue>0) temp+="</div>";
					temp+="<div id='scr"+alphvalue+"' class='container-fluid alphsection'><h5 class='alphabetstripe'><span>"+active_alphabet[alphvalue]+"</span></h5>";
				}
				var success=false;
				if (searchval=="") success=true;
				else
				{
					if (searchenglish)
					{
						var qqq=dbase[wordlist[i][2]][maincolumns[activestage]+1];//Needs improvemet
						if (qqq.search(searchval)!=-1) success=true;
					}
					else
					{
						if (wordlist[i][0].search(searchval)!=-1) success=true;
						if (wordlist[i][1].search(searchval)!=-1) success=true;
					}
				}
				if (success==true)
				{
					temp+="<div class='wordentry' onclick='openWord("+i+",false)'><h5>"+display(wordlist[i])+" <small>";
					j="???";
					for(var k=0;k<declensionlist.length;k++)
					{
						if (declensionlist[k][0]==wordlist[i][3]) j=dbase[declensionlist[k][1]][2];
					}
					temp+=j+"</small></h5></div>";
					foundresult++;
				}
			}
			while(alphvalue<active_alphabet.length-1)
			{
				alphvalue++;
				if (alphvalue>0) temp+="</div>";
				temp+="<div id='scr"+alphvalue+"' class='container-fluid alphsection'><h5 class='alphabetstripe'><span>"+active_alphabet[alphvalue]+"</span></h5>";
			}
			temp+="</div>";
			//Attach amount of found entries
			temp=" found.</small></div>"+temp;
			if (foundresult==1) temp="entry"+temp;
			else temp="entries"+temp;
			temp="<div id='entryamountbox' class='container-fluid'><small>"+foundresult+" "+temp;
			document.getElementById("wordlist").innerHTML=temp;
		}
	function display(term)
		{
			return(term[0]);
		}
	function openWotd()
		{
			var now=Date.now();//milliseconds
			now=Math.floor(now/1000);//seconds
			now=Math.floor(now/60);//minutes
			now=Math.floor(now/60);//hours
			now=Math.floor(now/24);//days
			now*=now;
			var wid=now % lexlist.length;
			openWord(wid,true);
		}
	function getPronunciation(word)
		{
			return(word);
		}
	function openWord(wid,first)
		{
			if (!first) $('.alert').alert("close");
			$('#tab_click_general').trigger("click");
			document.getElementById("entry_name").innerHTML=display(wordlist[wid]);
			var j="";
			var clid=-1;
			for(var i=0;i<declensionlist.length;i++)
			{
				if (declensionlist[i][0]==wordlist[wid][3])
				{
					j=dbase[declensionlist[i][1]][2];
					clid=i;
				}
			}
			document.getElementById("entry_category").innerHTML=j;
			
			var temp="";
			var translist=dbase[wordlist[wid][2]][maincolumns[activestage]+1].split(",");
			for(var i=0;i<translist.length;i++)
			{
				temp+="<li>";
				var k=translist[i].split("Â£");
				if (k.length>1) temp+="(<i>"+replaceAll("Â§",", ",k[1])+"</i>) ";
				temp+=k[0];
				temp+="</li>";
			}
			document.getElementById("entry_translations").innerHTML=temp;
			
			//Build pronunciation
			temp=dbase[wordlist[wid][2]][maincolumns[activestage]].toLowerCase();
			temp=getPronunciation((temp.split("~"))[0]);
			temp="<li>Debug: "+temp+"</li>";
			
			document.getElementById("entry_pronunciation").innerHTML=temp;
			
			//Build etymology
			temp="";
			var prevmeaning="";
			var startingpoint=-1;
			var stagecycle=activestage-1;
			for(var i=0;i<happenings.length;i++)
			{
				if (happenings[i][1]+2==stagelist[activestage][1]) startingpoint=i+1;
			}
			//else
			{
				for(var i=startingpoint;i>-2;i--)
				{
					if (i==-1)
					{
						if (temp!="") temp+=", ";
						temp+="from Proto-Indo-European ";
						if (dbase[wordlist[wid][2]][2]!="")
						{
							temp+="<i>*"+dbase[wordlist[wid][2]][2];
							temp+="</i>, from Proto-Indo-European ";
						}
						temp+="<i>*"+dbase[wordlist[wid][2]][1]+"</i>";
						if (dbase[wordlist[wid][2]][0]!="")
						{
							temp+=", from Proto-Indo-European ";
							temp+="<i>*"+dbase[wordlist[wid][2]][0]+"</i>";
						}
					}
					else if (dbase[wordlist[wid][2]][happenings[i][1]]!="")
					{
						if (temp!="") temp+=", ";
						if (happenings[i][0]!="VVV")
						{
							//Not inherited aka loan/contemporary derivation
							var temparr=dbase[wordlist[wid][2]][happenings[i][1]].split(" ");
							if (temparr[0].charAt(0)=="L")
							{
								//Loan
								temp+="loaned from "+parseLoan(temparr,prevmeaning,happenings[i][0]);
								i=-1; //Since it's not inherited, cancel the loop since we reached the earliest point
							}
						}
						else
						{
							temp+="from "+stagelist[stagecycle][0]+" <i>"+dbase[wordlist[wid][2]][happenings[i][1]];
							temp+="</i> (â€œ";
							if (dbase[wordlist[wid][2]][happenings[i][1]+1]==prevmeaning) temp+="id.";
							else
							{
								prevmeaning=dbase[wordlist[wid][2]][happenings[i][1]+1];
								temp+=replaceAll(",",", ",prevmeaning);
							}
							temp+="â€)"
							stagecycle--;
						}
					}
				}
			}
			document.getElementById("entry_etymologytext").innerHTML=(temp.charAt(0).toUpperCase()+temp.slice(1)+".").replace("..",".");
		}
	function updateStage()
		{
			activestage=document.getElementById("stageselectlist").selectedIndex;
			//Clear search bar
			document.getElementById("searchinputvalue").value="";
			//Load stage
			loadStage(activestage);
			
		}
	function cleanSearch()
		{
			document.getElementById("searchinputvalue").value="";
			var rv="";
			var radios=document.getElementsByName("search_destination");
			for(var i=0;i<radios.length;i++)
			{
				if (radios[i].checked) rv=radios[i].value;
			}
			if (rv=="eng") searchenglish=true;
			else searchenglish=false;
			setWordlist();
		}
</script>
</html>